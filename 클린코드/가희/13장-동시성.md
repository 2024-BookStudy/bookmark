# 13장 동시성

- 동시성과 깔끔한 코드는 양립하기 어렵다.

<br>

### 동시성이 필요한 이유?

- 동시성은 결합을 없애는 전략, ‘무엇’, ‘언제’를 분리하는 전략
- 무엇과 언제를 구분하면 애플리케이션 구조와 효율이 극적으로 나아진다.
    - 구조적인 관점에서 프로그램은 거대한 루프 하나가 아니라, 작은 협력 프로그램 여럿으로 보기이 때문

EX) 서블릿

- 웹 애플리케이션이 표준으로 사용하는 서블릿모델은 동시성을 부분적으로 관리한다.
- 웹 요청이 들어올 때 마다 웹 서버는 비동기적으로 서블릿을 실행
    - 각 서블릿 스레드는 다른 서블릿 스레드와 무관한 자신만의 세상에서 돌아감
 
<br>


## 동시성의 미신과 오해

### 1. 동시성은 항상 성능을 높여준다.

- 동시성은 때로 성능을 높여줌,
    - 대기 시간이 아주 길어, 여러 스레드가 프로세서를 공유할 수 있을 때
    - 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많을 때
 

<br>


### 2. 동시성을 구현해도 설계는 변하지 않는다.

- 단일스레드 설계와 다중 스레드 설계는 큰 차이가 있음

<br>



### 3. 웹 컨테이너를 사용하면 동시성을 이해할 필요가 없다.

- 실제로는 컨테이너가 어떻게 동작하는지, 어떻게 동시수정, 데드락과 같은 문제를 피할 수 있는지 알아야한다.

<br>



## 동시성의 타당한 생각

### 1. 동시성은 다소 부하를 유발

- 성능 측면에서 부하를 일으킴
- 코드도 더 짜야한다.

### 2. 동시성은 복잡하다.

- 간단한 문제라도 동시성은 복잡

### 3. 일반적으로 동시성 버그는 재현하기 어렵다.

- 따라서 진짜 결함으로 간주되지 않고 일회성 문제로 여겨, 무시하기 쉽다.

### 4. 동시성을 구현하려면 근본적인 설계 전략을 재고해야 한다.

<br>


---

## 동시성 방어 원칙

### 1. 단일 책임 원칙

- 동시성은 복잡성 하나 만으로 따로 분리할 이유가 충분하다.
    - 동시성 관련 코드는 다른 코드와 분리해야 한다.

### 2. 자료 범위를 제한하라.

- 코드 내 임계영역을 synchronized키워드로 보호하라
- 임계 영역의 수를 줄이는 기술이 중요하다.
- 공유 자료를 수정하는 위치가 많을수록 아래 가능성이 커진다.
    1. 보호할 임계 영역을 빼먹어, 공유 자료를 수정하는 모든 코드를 망가뜨린다. 
    2. 모든 임계영역을 올바르게 보호했는지 확인하느라 똑같은 노력과 수고를 반복
    3. 이미 찾기 힘든 버그인데 더 찾기 힘듬

- 해결방안 : 자료를 캡슐화하여, 공유 자료를 최대한 줄여라

### 3. 자료 사본을 사용하라

- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.
- 객체를 복사해 읽기 전용으로 사용하는 방법이 굳

### 4. 스레드는 가능한 독립적으로 구현

- 자신만의 세상에 존재하는 스레드를 구현
- 다른 스레드와 자료를 공유하지 않게!
- 각 스레드는 클라이언트 요청 하나를 처리하고, 모든 정보는 비공유 출처에서 가져오며 로컬 변수에서 저장하면 동기화 문제에서 벗어날 수 있당

### 5. 라이브러리를 이용하라

- 스레드 환경에 안전한 컬렉션을 사용하라
- 가능하다면 스레드 차단되지않는 방법을 사용하라
- 일부 클래스 라이브러리는 스레드안전핮하지 못하다

### 스레드 환경에 안정한 컬렉션 종류

1. **ConcurrentHashMap**
    
    스레드 안전한 HashMap 구현체입니다.
    
    락 분할(lock striping) 기법을 사용하여 높은 동시성을 제공합니다.
    
    개별 버킷(segment)에 대해 별도의 락을 사용하여 동시 접근을 허용합니다.
    

1. **CopyOnWriteArrayList**
    
    스레드 안전한 ArrayList 구현체입니다.
    
    데이터 변경 시 새로운 복사본을 생성하여 동시성 문제를 해결합니다.
    
    읽기 작업이 빈번한 경우에 유용합니다.
    

1. **ConcurrentLinkedQueue**
    
    스레드 안전한 Queue 구현체입니다.
    
    락 없이 동시 접근이 가능한 비차단 방식(lock-free)을 사용합니다.
    
    높은 동시성을 제공하며, 주로 생산자-소비자 패턴에 사용됩니다.
    
2. **ConcurrentSkipListSet, ConcurrentSkipListMap**
    
    스레드 안전한 Set과 Map 구현체입니다.
    
    정렬된 데이터 구조를 제공하며, 동시 접근이 가능합니다.
    
    스레드 안전성과 정렬 기능을 모두 필요로 하는 경우 유용합니다.
    

1. **BlockingQueue 구현체** 
    
    `ArrayBlockingQueue`, `LinkedBlockingQueue`, `PriorityBlockingQueue` 등이 있습니다.
    
    스레드 안전하며, 대기열에 데이터가 가득 차면 추가 작업을 차단합니다.
    
    생산자-소비자 패턴에서 널리 사용됩니다.
    

### 6. 실행 모델을 이해하라

- 다중 스레드 어플리케이션을 분류하는 방식은 여러가지, 구체적으로 아래 기본용어부터 이해해야함
![스크린샷 2024-06-30 오후 6 28 03](https://github.com/kbbookstudy/bookmark/assets/77230391/749e17ea-cf30-440b-a797-a85b2db0bda1)



## 다중 스레드에서 사용하는 실행모델

### 1. 생산자-소비자

- 하나 이상 생산자가 스레드 정보를 생성해 버퍼나 대기열에 넣음
- 하나이상 소비자가 대기열에서 정보를 가져와 사용
    
    ‘대기열’은 한정된 자원 
    
- 생산자, 소비자는 시그널을 이용해 소통

### 2. 읽기 쓰기

- 읽기 쓰레드를 위한 주된 정보원으로 공유자원을 사용하지만, 쓰기 스레드가 공유자원을 계속 갱신하려고 할떄,
- 대개는 쓰기 스레드가 버퍼를 오랫동안 점유하는 바람에 여러 읽기 스레드가 버퍼를 기다리느라 처리율이 떨어진다.

## 해법

### 1. 동기화하느 매서드 사이에 존재하는 의존성을 피하라

- 동기화하는 매서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생김
- 따라서 공유 객체 하나에는 매서드 하나만 사용

- 공유 객체 하나에 여러 매서드가 필요할 떄
    1. 클라이언트에서 잠금
    2. 서버에서 잠금
    3. 연결 서버 
    
    세개를 수행
    

### 2. 동기화 하는 부분을 작게 만들어라

- 자바에서는 synchronize키워드를 사용하면 ㄹ착이 설정됨
- 같은 락으로 감싼 모든 코드는 한 번에 스레드 한개만 실행 가능
- 코드를 짤 때 임계영역의 수를 최대한 줄이고, 임계 영역의 크기도 줄여야함

### 올바른 종료 코드는 구현하기 어려움

- 깔끔하게 종료하는 코드는 올바르게 구현하기 ㅇ려움
- 가장 흔히 발생하는 것은 데드락
- 따라서 종료코드를 개발 초기부터 고민하고 동작하게 초기부터 구현, 생각보다 어려우므로 이미 나온 알고리즘을 검토하자

### 3. 스레드 코드 테스트하기

- 문제를 노출하는 테스트케이스를 작성
- 프로그램 설정과 시스템 설정, 부하를 자주 바꿔가며 자주 돌려라
- 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 절대 안된다.
1. 말이안되는 실패는 잠정적인 스레드 문제로 취급
2. 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
3. 프로세서 수보다 많은 스레드를 돌려봐라
4. 다른 플렛폼에서 돌려봐라, 
5. 코드에 보조 코드를 넣어 돌려라 강제로 실패하게 만들자 

# 대기열

https://junuuu.tistory.com/881

```java
// 주문 처리 큐
BlockingQueue<Order> orderQueue = new LinkedBlockingQueue<>();

// 주문 생산자 스레드
public class OrderProducer implements Runnable {
    @Override
    public void run() {
        while (true) {
            Order order = getOrderFromWebsite(); // 웹사이트에서 주문 받기
            try {
                orderQueue.put(order); // 주문 큐에 추가
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

// 주문 소비자 스레드
public class OrderConsumer implements Runnable {
    @Override
    public void run() {
        while (true) {
            try {
                Order order = orderQueue.take(); // 주문 큐에서 주문 가져오기
                processOrder(order); // 주문 처리
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

// 메인 메서드
public static void main(String[] args) {
    // 주문 생산자와 소비자 스레드 생성 및 시작
    Thread producer = new Thread(new OrderProducer());
    Thread consumer = new Thread(new OrderConsumer());
    producer.start();
    consumer.start();
}

```

https://soobysu.tistory.com/76

https://duddal.tistory.com/62
