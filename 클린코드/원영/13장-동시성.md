# 13장 동시성
동시성과 깔끔한 코드는 양립하기 어렵다

부하를 받기 전까지는 다중 스레드의 깊숙한 곳에 있는 문제를 찾기 어렵다

  

## 동시성이 필요한 이유 ?

- 동시성은 **결합**을 없애는 전략이다
- **무엇**(what)과 **언제**(when)를 분리하는 전략
- 단일 스레드는 무엇과 언제가 서로 밀접함.
- 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다
- 구조적 관점에서 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 보인다.
- 응답시간과 작업 처리량을 개선하려면 직접적인 동시성 구현이 불가피하다
- 동시성이 필요한 상황이 존재한다

## 미신과 오해

동시성에 대한 오해

- 동시성은 항상 성능을 높여준다 → 동시성은 **때로** 성능을 높여준다(여러 프로세서가 동시에 처리할 독립적인 계산이 많은 경우만 성능이 높아짐)
- 동시성을 구현해도 설계는 변하지 않는다
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
    - 실제로는 컨테이너가 어떻게 동작하는지, 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지 알아야만 한다.

동시성에 대한 타당한 생각

- 동시성은 다소 부하를 유발한다. 성능 측면에서 부하가 걸리며, 코드도 더 짜야 한다.
- **동시성은 복잡하다.**
- **일반적으로 동시성 버그는 재현하기 어렵다**
- 동시성을 구현하려면 근본적인 설계 전략을 재고해야 한다.

## 동시성 방어 원칙

동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙과 기술

### 단일 책임 원칙(Single Responsibility Principle, SRP)

- 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙
- **동시성 관련 코드는 다른 코드와 분리해야 한다.**
    - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다

### 따름 정리(corollary)

- 자료 범위를 제한하라
    - 공유 객체를 사용하는 코드 내 **임계영역**을 **synchronized** 키워드로 보호하라
- 자료를 캡슐화 하라. 공유 자료를 최대한 줄여라.

### 자료 사본을 사용하라

- 공유 자료를 줄이려면 처음부터 공유하지 않는 것이 제일 좋다
- 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법도 가능
    - 사본으로 동기화를 피할 수 있다면 내부 잠금을 없애 절약한 수행 시간이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다

### 스레드는 가능한 독립적으로 구현하라

- 각 스레드는 클라이언트 요청 하나를 처리하라. 다른 스레드와 자료를 공유하지 말아라.
- 마치 세상에 자신만 있는 듯이 돌아가게 해라. 다른 스레드와 동기화할 필요 없다.
- 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.

## 라이브러리를 이해하라

- 자바 5부터 스레드 환경에 안전한 컬렉션을 사용한다
- 각 언어가 제공하는 클래스를 검토하라 !

## 실행 모델을 이해하라

스레드 관련 기본 용어

- 한정된 자원 : 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적(버퍼, 데이터베이스 연결 등)
- 상호 배제 : 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킴
- 기아 : 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다.
    - 처리율을 강조하면 기아 현상이 생기거나 오래된 정보가 쌓인다
- 데드락 : 여러 스레드가 서로 끝나기를 기다림
- 라이브락 : 락을 거는 단계에서 각 스레드가 서로를 방해한다

## 동기화하는 메서드 사이에는 존재하는 의존성을 이해하라

- 동기화 하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다
- 자바 언어는 개별 메서드를 보호하는 synchronized라는 개념을 지원한다
- 공유 객체 하나에는 메서드 하나만 사용하라 !!

공유 객체 하나에 여러 메서드가 필요한 경우 다음 세 가지 방법을 고려

1. 클라이언트에서 잠금 - 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다. 마지막 메서드를 호출할 때까지 잠금 유지
2. 서버에서 잠금 - 서버에 “모든 메서드의 호출이 마무리 될 때까지 잠금 후 해제”하는 메서드를 설정 후 클라이언트에서 이 메서드 호출 
3. 연결 서버 - 잠금을 수행하는 중간 단계를 생성

## 동기화 하는 부분을 작게 만들어라

- 자바에서 synchronized 키워드를 사용하면 락을 설정한다
    - 같은 락으로 감싼 코드 영역은 한 번에 한 스레드만 실행이 가능하다
    - 락은 스레드를 지연시키고 부하를 가중시킨다
- synchronized 문을 남발하지 말아라
- 임계영역은 반드시 보호해야 한다

## 올바른 종료 코드는 구현하기 어렵다

- 자식 스레드가 데드락에 걸린다면 부모 스레드는 영원히 기다리게 된다.
    - 시스템은 영원히 종료되지 못한다
- 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현해라 !

## 스레드 코드 테스트하기

- 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라
- 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라
- 프로세서 수보다 많은 스레드를 돌려보라
- 다른 플렛폼에서 돌려보라
- 강제로 실패를 일으키게 해보라

## 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라

- 일회성 문제란 존재하지 않는다. 문제가 발생했다면 추후 또 생길 수 있다
- 시스템 실패를 **일회성**으로 치부하지 마라