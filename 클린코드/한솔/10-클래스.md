10장. 클래스
=========

## 클래스 체계
- <code>static public</code> -> <code>static private</code> -> <code>private instance</code>
    공개 변수가 필요한 경우는 거의 없다.
- 변수 다음으로 <code>public function</code>이 나오고 <code>private function</code>은 호출된 함수 직후에 넣는다.
추상화 단계를 순차적으로 나타냄

## 캡슐화
- 비공개 상태를 유지할 온갖 방법을 강구한 후에 캡슐화를 풀어줄 수 있도록한다.

## 클래스는 작아야 한다!
- 클래스 이름은 해당 클래스 책임을 기술해야 한다.
    클래스의 기능이 <code>if, and, or, but</code>을 사용하지 않아야 한다.

## 단일 책임 원칙
- 버전 관련, 스윙 컴포넌트 관련 기능은 변경될 여지가 있다.
    따라서, 버전이라는 독자적인 클래스를 만든다.

## 응집도
- 클래스는 인스턴스 변수 수가 작아야 한다.
    메서드가 변수를 많이 사용할수록 응집도가 높다.
- 몇몇 메서드만이 사용하는 인스턴스 변수가 있다면 이것은 새로운 클래스로 쪼개야 한다는 신호다.

## 응집도를 유지하면 작은 클래스 여럿이 나온다.
- 리팩토링 결과 <code>PrimePrinter</code> 클래스는 <code>main</code> 함수 하나만 포함하며 실행 환경을 책임진다.
- <code>RowColumPagePrinter</code> 클래스는 페이지에 출력하는 방법을 안다.
- <code>PrimeGenerator</code> 클래스는 소수 목록을 생성하는 방법이다.

## 변경하기 쉬운 클래스
- 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다.
- <code>Sql</code>클래스에 여러 기능을 모아놓는 것은 SRP(단일 책임 원칙)을 위반한다.
    따라서 여러 기능을 <code>Sql</code> 클래스에서 파생하는 클래스로 만든다.   
  
    비공개 메서드는 해당 파생 클래스로 옮기고, 모든 파생 클래스가 공통으로 사용하는 비공개 메서드는 유틸리티 클래스에 넣는다.   
    이렇게 되면 update문이 추가 되었을 때 <code>Sql</code> 클래스에서 새 클래스 <code>UpdateSql</code>을 상속받아 넣으면 그만이다.
  
    OCP도 지원한다.
    : 클래스는 확장에 개방적이고 수정에 폐쇠적어야 한다.

## 변경으로부터 격리
- 상세한 구현은 인터페이스와 추상 클래스를 사용해 격리한다.
- 각 시스템 요소가 다른 요소와 변경으로부터 격리된다면 유연성과 재사용성이 높아진다.   
    클래스 설계 원칙인 *DIP*를 따르는 클래스가 나온다.   
    : 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙
