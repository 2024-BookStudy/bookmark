8장. 경계
=======

## 외부 코드 사용하기

- 유용하지만 그만큼 위험도 크다
- *Map*을 사용한다고 가정했을때   
  1. <code>close()</code>라는 메서드가 존재하는데, 누구나 *Map*의 내용을 지울 권한이 있다.
  2. 특정 객체 유형만 저장하기로 규칙을 정했지만 *Map*은 **객체 유형을 제한하지 않는다.**
  3. 제네릭스를 사용할 경우 *Map* 인스턴스를 여기저기로 넘긴다면, Map 인터페이스 **변경 시 수정할 코드가 상당히 많다.**  
  ```
  Map<String, Senser> sensors = new HashMap<Sensor>();
  sensors.get(sensorId);
  ```
  x
  ```
  public class Sensors {
      private Map sensors = new HashMap();
      
      public Sensor getById(String id) {
          return (Sensor) sensors.get(id);
      }
  }
  ```
  o   
  <code>Sensors</code> 사용자는 제네릭스가 사용되었는지 여부에 신경 쓸 필요가 없다.    
  제네릭스의 사용 여부는 <code>Sensors</code> 안에서 결정한다.    
  경계 인터페이스인 Map을 <code>Sensors</code> 안으로 숨긴다.    
  이 때 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다.    
  *Map* 인스턴스를 공개 API의 인수나 반환값으로 사용하지 않는다.    

## 경계 살피고 익히기
- 외부 코드를 사용할 때, 간단한 테스트 케이스를 작성해 익힌다.

## 학습 테스트는 공짜 이상이다.
- 이해도를 높여주는 실험이다.
- 필요하지 않든, 실제 코드와 동일한 방식으로 사용하는 테스트 케이스가 필요하다.

## 아직 존재하지 않느 코드를 사용하기
- 다른 팀에서 송신기 시스템을 작업하기로 했다.
- 아직 정해진 것이 없었기에 송신기 시스템과 먼 부분부터 작업한다.
- 점차 필요한 경계 인터페이스가 무엇인지 알게 된다.
- <code>ADAPTER 패턴</code>으로 API 사용을 캡슐화해 API가 바뀔 때 수정할 코드를 한곳으로 모은다.

## 깨끗한 경계
- 경계에 위치하는 코드는 깔끔히 분리한다.
- 기대치를 정의하는 테스트 케이스도 작성해야 한다.
- 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리한다.
- 새로운 클래스로 **경계를 감싸거나** <code>ADAPTER</code> 패턴을 사용하여 인터페이스를 만든다.
  
