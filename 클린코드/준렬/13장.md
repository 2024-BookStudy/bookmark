# 13장 동시성

### 객체와 스레드의 추상화

**객체는 처리의 추상화이며, 스레드는 일정의 추상화.** 동시성과 깔끔한 코드는 양립하기 어려우며, 특히 다중 스레드 코드는 겉보기에는 멀쩡해 보이지만 시스템이 부하를 받을 때 문제가 발생할 수 있다. 

### 동시성이 필요한 이유

동시성은 결합(coupling)을 없애는 전략으로, "무엇"과 "언제"를 분리한다. 스레드가 하나인 프로그램은 무엇과 언제가 밀접하게 연결되어 있어, 호출 스택을 통해 프로그램 상태를 쉽게 파악할 수 있다. 그러나 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 개선된다.

예를 들어, 웹 애플리케이션의 서블릿(Servlet) 모델을 보면, 웹 서버는 비동기식으로 서블릿을 실행하여 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 작동한다. 이는 구조적인 이점을 제공한다. 하지만 동시성 구현은 서블릿 프로그래머가 주의 깊게 다루어야 할 부분이다.

### 동시성의 필요성 예시

- **정보 수집기**: 여러 웹사이트에서 정보를 가져오는 수집기가 단일 스레드라면 시간이 오래 걸리지만, 다중 스레드 알고리즘을 사용하면 성능이 향상된다.
- **다중 사용자 시스템**: 단일 스레드는 많은 사용자가 있을 때 응답 시간이 길어지지만, 다중 스레드를 사용하면 성능이 개선된다.
- **대량 정보 분석 시스템**: 정보를 여러 컴퓨터에서 병렬로 처리하면 효율적이다.

### 미신과 오해

- **동시성은 항상 성능을 높여준다 →** 대기 시간이 길거나 독립적인 계산이 많은 경우에만 성능이 높아짐
- **동시성을 구현해도 설계는 변하지 않는다 →** 단일 스레드 시스템과 다중 스레드 시스템의 설계는 다릅니다.
- **컨테이너를 사용하면 동시성을 이해할 필요가 없다 →** 컨테이너 동작과 동시 수정, 데드락 등을 이해해야 한다.

### 동시성 방어 원칙

1. **단일 책임 원칙(SRP)**: 동시성 관련 코드는 다른 코드와 분리해야 한다.
2. **자료 범위 제한**: 공유 자료를 최대한 줄이고 캡슐화해야 한다.
3. **자료 사본 사용**: 공유 객체를 피하기 위해 객체를 복사해 읽기 전용으로 사용하는 방법이 있다.
4. **스레드 독립성**: 각 스레드가 독립적으로 동작하도록 구현한다.
5. **라이브러리 활용**: 자바에서는 `java.util.concurrent`, `java.util.concurrent.atomic`, `java.util.concurrent.locks`를 이용하여 동시성 문제를 해결할 수 있다.

### 기본 실행 모델

- **생산자-소비자 모델**: 생산자 스레드가 정보를 생성해 대기열에 넣고 소비자 스레드가 이를 소비한다.
- **읽기-쓰기 모델**: 읽기 스레드와 쓰기 스레드가 공유 자원을 이용하며, 이들 사이의 균형을 맞춰야 한다.
- **식사하는 철학자 문제**: 여러 스레드가 자원을 공유할 때 발생하는 데드락, 라이브락 등의 문제를 해결해야 한다.

### 동기화의 이해

동기화하는 메서드 사이의 의존성을 이해하고 공유 객체 하나에는 메서드 하나만 사용하는 것이 좋다. 공유 객체에 여러 메서드가 필요한 경우, 클라이언트에서 잠금(lock)을 사용하여 관리한다.