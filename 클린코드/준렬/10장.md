# 10장 클래스

### 클래스 체계

- 클래스 정의 시 가장 먼저 변수 목록이 나와야 함.
- 정적(public) 상수 → 정적(private) 변수 → 인스턴스(private) 변수 순으로 나열.
- 공개 함수는 비공개 함수보다 먼저 나와야 하며, 비공개 함수는 호출하는 공개 함수 직후에 배치.

### 캡슐화

- 변수와 유틸리티 함수는 가능한 공개하지 말아야 함.
- 테스트 코드에서 접근이 필요한 경우 `protected`로 선언.
- 캡슐화는 언제나 최후의 수단으로 풀어야 함.

### 클래스는 작아야 한다!

- 클래스는 가능한 작게 설계해야 함.
- 클래스의 크기는 물리적 크기보다는 책임의 수로 측정.
- 클래스 이름이 모호하거나 길다면 책임이 많다는 신호.
- 클래스 설명은 25단어 이내로 간결하게 작성.

### 단일 책임 원칙 (SRP)

- 클래스는 변경할 이유가 하나만 있어야 함.
- 책임이 많은 클래스는 작은 단일 책임 클래스로 분리.
- 예를 들어, `SuperDashboard` 클래스는 버전 관리와 UI 관리를 동시에 담당하면 안 됨.

### 응집도 (Cohesion)

- 클래스의 인스턴스 변수는 적을수록 좋음.
- 메서드는 하나 이상의 인스턴스 변수를 사용해야 함.
- 응집도가 높은 클래스는 논리적으로 관련된 메서드와 변수를 포함.

### 많은 책임을 가지고 있었던 긴 클래스인 `PrintPrimes` 리팩토링 후의 구조.

1. `PrimePrinter` 클래스:
    - 메인 함수와 실행 환경을 책임짐.
2. `RowColumnPagePrinter` 클래스:
    - 숫자 목록을 행과 열에 맞춰 페이지에 출력.
3. `PrimeGenerator` 클래스:
    - 소수 목록을 생성.

리팩토링 후 프로그램은 길어졌지만, 가독성과 유지보수성이 크게 향상되었습니다.

### 결론

- 클래스를 작게 유지하고 단일 책임 원칙을 따르는 것이 중요.
- 응집도를 높여 관련된 메서드와 변수를 함께 묶어야 함.
- 리팩토링을 통해 프로그램을 논리적으로 분리하고 가독성을 높이는 것이 바람직.