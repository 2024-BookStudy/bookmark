### 7장. 오류 처리

#### 오류 처리와 클린 코드
> 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. 이 둘은 상충하는 목표가 아니다. 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다. 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다.
 
#### 오류 처리 기법과 고려 사항
- 오류 코드보다 예외를 사용하기
- Try-Catch-Finally 문부터 사용하기
- 미확인unchecked 예외를 사용하기
- 예외에 의미 제공하기
- 호출자를 고려해 예외 클래스를 정의하기
- 정상 흐름을 정의하기
- null을 반환하지 않기
- null을 전달하지 않기
   

**오류코드 -> 예외**
오류 플래그, 호출자에게 오류 코드 반환 -> 호출자 코드 복잡
오류가 발생하면 예외를 던지기 -> 논리/오류 처리코드 혼동 X


**Try-Catch-Finally 문**
try 블록은 트랜잭션과 유사.
catch 블록은 프로그램 상태를 일관성 있게 유지해야 함.
예외 발생 코드를 try-chach-finally문으로 작성하면 try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워짐.
> 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다. 그러면 자연스럽게 try 블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다!

**미확인unchecked 예외**
확인된 예외는 OCP를 위반한다. -> 최하위 선언부에서 오류를 던지면 최하위부터 최상위까지 연쇄적인 수정이 일어나며, 캡슐화가 깨짐.

**예외에 의미를 제공**
1) 예외를 던질 때는 전후 상황을 충분히 덧붙인다.
2) 오류 메시지에 정보를 담아 예외와 함께 던진다. 
3) 실패한 연산 이름과 실패 유형을 언급한다. 
4) 애플리케이션이 로깅 기능을 사용한다면, catch 블록에서 오류를 기록하도록 충분한 정보를 넘겨준다.

**호출자를 고려하여 예외 클래스 정의**
오류 분류의 핵심은 오류를 잡아내는 방법이다. 외부 API를 감싸는 클래스는 의존성을 줄이고 테스트를 쉽게 만들어준다. 하나의 예외 클래스로도 충분하며, 필요에 따라 여러 예외를 사용할 수 있다.

**정상 흐름을 정의**
특수 사례 패턴 : 예외가 논리를 따라가기 어려울 때 특수상황을 정의하여 해결한다.
클래스를 만들거나 객체를 조착해 특수 사례를 처리하는 방식이다.
-> 클라이언트 코드가 예외적인 상황을 처리할 필요 X = 클래스나 객체가 예외 상황을 캡슐화하여 처리

**Null 반환 하지 않기**
사용하려는 외부 API가 null을 반환한다면 감싸기 메서드를 구현해 예외를 던지거나 특수 사례 객체를 반환하는 방식을 고려 -> 클린 코드, NullPointerException 발생 가능성 저하 

**Null 전달하지 않기**
null 반환보다 더 나쁜 것은 null 전달.
정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null 전달하는 코드는 최대한 피한다. -> 누군가 인수로 null을 전달하면 NullPointerException 발생..
- 해결 방안 : 새로운 예외 유형 만들기, assert문 사용

호출자가 실수로 넘기는 null을 처리하는 방법이 없기 때문에 애초에 null을 넘기지 못하도록 금지하는 것이 합리적. 인수로 null이 넘어오면 코드에 문제 O